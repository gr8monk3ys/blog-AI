-- Migration: Create conversations table
-- Description: Stores conversation history (replacing file-based storage)

-- Create the conversations table
CREATE TABLE IF NOT EXISTS conversations (
    id TEXT PRIMARY KEY,  -- UUID from frontend
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    -- Conversation data
    messages JSONB NOT NULL DEFAULT '[]'::JSONB,

    -- Optional metadata
    metadata JSONB
);

-- Create indexes
CREATE INDEX idx_conversations_created_at ON conversations(created_at DESC);
CREATE INDEX idx_conversations_updated_at ON conversations(updated_at DESC);

-- Auto-update updated_at timestamp
CREATE TRIGGER update_conversations_updated_at
    BEFORE UPDATE ON conversations
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Enable Row Level Security
ALTER TABLE conversations ENABLE ROW LEVEL SECURITY;

-- Policy: Service role can do everything
CREATE POLICY "Service role has full access to conversations"
    ON conversations
    FOR ALL
    TO service_role
    USING (true)
    WITH CHECK (true);

-- Policy: Anonymous users can create and read conversations
CREATE POLICY "Anonymous can manage conversations"
    ON conversations
    FOR ALL
    TO anon
    USING (true)
    WITH CHECK (true);

-- Function: Upsert conversation (create or update)
CREATE OR REPLACE FUNCTION upsert_conversation(
    p_id TEXT,
    p_messages JSONB,
    p_metadata JSONB DEFAULT NULL
)
RETURNS conversations AS $$
DECLARE
    result conversations;
BEGIN
    INSERT INTO conversations (id, messages, metadata)
    VALUES (p_id, p_messages, p_metadata)
    ON CONFLICT (id)
    DO UPDATE SET
        messages = p_messages,
        metadata = COALESCE(p_metadata, conversations.metadata),
        updated_at = NOW()
    RETURNING * INTO result;

    RETURN result;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function: Add message to conversation
CREATE OR REPLACE FUNCTION add_conversation_message(
    p_id TEXT,
    p_message JSONB
)
RETURNS conversations AS $$
DECLARE
    result conversations;
BEGIN
    INSERT INTO conversations (id, messages)
    VALUES (p_id, jsonb_build_array(p_message))
    ON CONFLICT (id)
    DO UPDATE SET
        messages = conversations.messages || p_message,
        updated_at = NOW()
    RETURNING * INTO result;

    RETURN result;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Grant execute permissions
GRANT EXECUTE ON FUNCTION upsert_conversation(TEXT, JSONB, JSONB) TO anon, authenticated, service_role;
GRANT EXECUTE ON FUNCTION add_conversation_message(TEXT, JSONB) TO anon, authenticated, service_role;

COMMENT ON TABLE conversations IS 'Stores conversation history for content generation sessions';
COMMENT ON COLUMN conversations.id IS 'UUID generated by the frontend';
COMMENT ON COLUMN conversations.messages IS 'Array of messages in the conversation';
COMMENT ON COLUMN conversations.metadata IS 'Optional metadata (topic, settings, etc.)';
